import { toVercelChatMessages } from '@/lib/ai/message-utils';
import { streamText } from 'ai';
import { ratelimit } from '@/lib/server/ratelimiter';
import { epochTimeToNaturalLanguage } from '@/lib/utils';
import type { Sandbox } from '@e2b/code-interpreter';
import { pauseSandbox } from '@/lib/tools/e2b/sandbox';
import { createAgentTools } from '@/lib/ai/tools/agent';
import { PENTESTGPT_AGENT_SYSTEM_PROMPT } from '@/lib/models/agent-prompts';
import { myProvider } from '@/lib/ai/providers';
import { executeTerminalCommandWithConfig } from './terminal-command-executor';
import {
  generateTitleFromUserMessage,
  handleChatAndMessages,
} from '@/lib/ai/actions';
import type { ChatMetadata, LLMID, ModelParams, FileAttachment } from '@/types';
import type { SupabaseClient } from '@supabase/supabase-js';
import { handleMessageAttachments } from '@/lib/ai/tools/agent/utils/file-db-utils';
import { DefaultSandboxManager } from './agent/utils/sandbox-manager';
import { waitUntil } from '@vercel/functions';
import PostHogClient from '@/app/posthog';
import { buildSystemPrompt } from '../prompts';

interface PentestAgentConfig {
  messages: any[];
  modelParams: ModelParams;
  chatMetadata: ChatMetadata;
  profile: any;
  dataStream: any;
  abortSignal: AbortSignal;
  model: LLMID;
  supabase: SupabaseClient | null;
  userCountryCode: string | null;
  autoSelected?: boolean;
  isAgentAPI?: boolean;
  originalMessages?: any[];
}

export async function executePentestAgent({
  config,
}: {
  config: PentestAgentConfig;
}) {
  const {
    modelParams,
    chatMetadata,
    profile,
    dataStream,
    abortSignal,
    model,
    supabase,
    userCountryCode,
    autoSelected,
  } = config;
  let messages = config.messages;

  let sandbox: Sandbox | null = null;
  const userID = profile.user_id;
  // Track if port exposure tool was used
  let exposedPort = false;

  // Create sandbox manager
  const sandboxManager = new DefaultSandboxManager(
    userID,
    dataStream,
    (newSandbox) => {
      sandbox = newSandbox;
    },
    sandbox,
  );

  try {
    // Check rate limit
    if (autoSelected) {
      const rateLimitResult = await ratelimit(userID, 'terminal');
      if (!rateLimitResult.allowed) {
        const waitTime = epochTimeToNaturalLanguage(
          rateLimitResult.timeRemaining!,
        );
        dataStream.writeData({
          type: 'error',
          content: `⚠️ You've reached the limit for terminal usage.\n\nTo ensure fair usage for all users, please wait ${waitTime} before trying again.`,
        });
        return 'Rate limit exceeded';
      }
    }

    const posthog = PostHogClient();
    if (posthog) {
      posthog.capture({
        distinctId: userID,
        event: 'pentest_agent_executed',
      });
    }

    // Try to execute terminal command if confirmTerminalCommand is true
    if (modelParams.confirmTerminalCommand) {
      const result = await executeTerminalCommandWithConfig({
        userID,
        dataStream,
        sandboxManager,
        messages,
      });

      if (typeof result === 'string') return result;
      messages = result.messages;
    }

    const systemPrompt = buildSystemPrompt(
      PENTESTGPT_AGENT_SYSTEM_PROMPT,
      profile.profile_context,
    );

    let generatedTitle: string | undefined;
    let customFinishReason: string | null = null;
    let assistantMessage = '';
    const fileAttachments: FileAttachment[] = [];

    // Create a wrapper for dataStream.writeData to capture content
    const originalWriteData = dataStream.writeData;
    dataStream.writeData = (data: any) => {
      if (data.type === 'text-delta' && data.content) {
        assistantMessage += data.content;
      } else if (
        data.type === 'file-attachment' &&
        Array.isArray(data.content)
      ) {
        fileAttachments.push(...data.content);
      }
      originalWriteData(data);
    };

    abortSignal.addEventListener('abort', async () => {
      if (config.isAgentAPI && chatMetadata.id && supabase) {
        waitUntil(
          handleChatAndMessages({
            supabase,
            modelParams,
            chatMetadata,
            profile,
            model,
            messages: config.originalMessages || messages,
            title: generatedTitle,
            finishReason: 'aborted',
            assistantMessage,
            fileAttachments,
          }),
        );
      }
    });

    await Promise.all([
      (async () => {
        const { fullStream, finishReason } = streamText({
          model: myProvider.languageModel('chat-model-agent'),
          maxTokens: 4096,
          system: systemPrompt,
          messages: toVercelChatMessages(messages, true),
          tools: createAgentTools({
            dataStream,
            sandbox,
            userID,
            setSandbox: sandboxManager.setSandbox.bind(sandboxManager),
            agentMode: modelParams.agentMode,
            sandboxManager,
            userCountryCode,
          }),
          maxSteps: 10,
          toolChoice: 'required',
          abortSignal,
          onChunk: async (chunk) => {
            if (chunk.chunk.type === 'tool-call') {
              dataStream.writeData({
                type: 'agent-status',
                content: 'thinking',
              });

              // Check if the expose port tool is being used
              if (
                chunk.chunk.toolName === 'deploy_expose_port' ||
                chunk.chunk.toolName === 'shell_background'
              ) {
                exposedPort = true;
              }
            }
          },
          onError: async (error) => {
            if (
              !(
                error instanceof Error &&
                error.name === 'AI_InvalidToolArgumentsError'
              )
            ) {
              console.error('[TerminalAgent] Stream Error:', error);
            }
          },
          onFinish: async ({ finishReason }: { finishReason: string }) => {
            if (supabase) {
              await handleChatAndMessages({
                supabase,
                modelParams,
                chatMetadata,
                profile,
                model,
                messages: config.originalMessages || messages,
                finishReason: customFinishReason
                  ? customFinishReason
                  : finishReason,
                title: generatedTitle,
                assistantMessage,
                fileAttachments,
              });
            }
          },
        });

        // Handle stream
        let shouldStop = false;
        for await (const chunk of fullStream) {
          if (chunk.type === 'tool-call') {
            if (chunk.toolName === 'idle') {
              dataStream.writeData({ finishReason: 'idle' });
              customFinishReason = 'idle';
              shouldStop = true;
            } else if (chunk.toolName === 'message_ask_user') {
              dataStream.writeData({
                type: 'text-delta',
                content: chunk.args?.text,
              });

              // Handle attachments if provided
              if (chunk.args?.attachments) {
                await handleMessageAttachments({
                  attachments: chunk.args.attachments,
                  userID,
                  dataStream,
                  sandboxManager,
                });
              }

              dataStream.writeData({ finishReason: 'message_ask_user' });
              customFinishReason = 'message_ask_user';
              shouldStop = true;
            } else if (
              modelParams.agentMode === 'ask-every-time' &&
              chunk.toolName === 'shell_exec'
            ) {
              const { exec_dir, command } = chunk.args;
              dataStream.writeData({
                type: 'text-delta',
                content: `<terminal-command exec-dir="${exec_dir}">${command}</terminal-command>`,
              });
              dataStream.writeData({
                finishReason: 'terminal_command_ask_user',
              });
              customFinishReason = 'terminal_command_ask_user';
              shouldStop = true;
            }
          }
        }

        // Send finish reason if not already sent
        if (!shouldStop) {
          const originalFinishReason = await finishReason;
          dataStream.writeData({ finishReason: originalFinishReason });
        }
      })(),
      (async () => {
        if (chatMetadata.id && chatMetadata.newChat && !autoSelected) {
          generatedTitle = await generateTitleFromUserMessage({
            messages,
            abortSignal,
          });
          dataStream.writeData({ chatTitle: generatedTitle });
        }
      })(),
    ]);

    return 'Terminal execution completed';
  } catch (error) {
    console.error('[TerminalAgent] Error:', {
      error: error instanceof Error ? error.message : 'Unknown error',
    });
    dataStream.writeData({
      type: 'error',
      content: 'An error occurred during terminal execution. Please try again.',
    });
    throw error;
  } finally {
    // Don't pause sandbox if we've exposed a port, to keep services running for additional time
    if (sandbox) {
      if (!exposedPort) {
        await pauseSandbox(sandbox);
      } else {
        // console.log('[TerminalAgent] Keeping sandbox active for exposed port');
      }
    }
  }
}
